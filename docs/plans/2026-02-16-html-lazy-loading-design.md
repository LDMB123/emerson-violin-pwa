# HTML Lazy Loading Design

## Goal

Reduce index.html from 172 KB to ~15 KB by extracting 44 inline views to separate files and loading them on-demand.

## Problem

Current state:
- index.html: 172 KB uncompressed, 21.4 KB gzipped, 3381 lines
- Contains 44 inline views (15 core + 18 songs + 11 games)
- All views parsed on initial load despite only showing one
- High parse time cost for content never immediately used

## Approach: Lazy HTML Loading with Fetch

Extract all 44 views to separate HTML files and load on-demand via fetch API with in-memory caching.

### Benefits
- **Initial load**: 172 KB → ~15 KB (91% reduction)
- **Parse time**: Minimal - only shell HTML parsed initially
- **Network**: First view load +1 request (~3-5 KB), then cached
- **Maintenance**: Simple architecture, easy to debug

### Trade-offs
- +50ms navigation delay on first view load (then instant from cache)
- Requires HTTPS/localhost for fetch API (already required for PWA)
- Service worker needs updates for offline support

## Architecture

### File Structure

```
views/
├── home.html
├── tune.html
├── record.html
├── games.html
├── settings.html
├── songs/
│   ├── twinkle-twinkle.html
│   ├── mary-lamb.html
│   └── ... (18 total)
└── games/
    ├── pitch-quest.html
    ├── rhythm-match.html
    └── ... (11 total)
```

### ViewLoader Module

**Purpose:** Centralized view loading with caching and deduplication

**Core functionality:**
```javascript
// src/views/view-loader.js
class ViewLoader {
  constructor() {
    this.cache = new Map(); // In-memory cache
    this.loading = new Map(); // Prevent duplicate fetches
  }

  async load(viewPath) {
    // Return cached if available
    if (this.cache.has(viewPath)) {
      return this.cache.get(viewPath);
    }

    // Wait if already loading
    if (this.loading.has(viewPath)) {
      return this.loading.get(viewPath);
    }

    // Fetch and cache
    const promise = fetch(viewPath)
      .then(r => r.ok ? r.text() : Promise.reject(`HTTP ${r.status}`))
      .then(html => {
        this.cache.set(viewPath, html);
        this.loading.delete(viewPath);
        return html;
      })
      .catch(err => {
        this.loading.delete(viewPath);
        throw err;
      });

    this.loading.set(viewPath, promise);
    return promise;
  }

  clearCache() {
    this.cache.clear();
  }
}
```

**Features:**
- In-memory cache (Map for O(1) lookups)
- Duplicate fetch prevention (single promise shared)
- Error propagation with cleanup
- Cache clearing for debugging

### Router Integration

**Current flow:**
```javascript
// Old way - toggle visibility of inline views
function navigate(viewId) {
  document.querySelectorAll('.view').forEach(v => v.classList.remove('active'));
  document.getElementById(viewId).classList.add('active');
}
```

**New flow:**
```javascript
// New way - load view HTML on demand
async function navigate(viewId) {
  const viewPath = getViewPath(viewId);
  const html = await viewLoader.load(viewPath);
  document.getElementById('main-container').innerHTML = html;
  initializeView(viewId); // Run view-specific JS
}
```

**Path mapping:**
```javascript
function getViewPath(viewId) {
  if (viewId.startsWith('song-')) return `views/songs/${viewId.slice(5)}.html`;
  if (viewId.startsWith('game-')) return `views/games/${viewId.slice(5)}.html`;
  return `views/${viewId}.html`;
}
```

### Service Worker Updates

**Precaching strategy:**
- Add all view files to precache manifest
- Cache-first strategy (instant load after first fetch)
- Version with build hash for updates

**Cache list generation:**
```javascript
// scripts/build-sw-assets.js enhancement
function getViewFiles() {
  const views = [];
  const dirs = ['views', 'views/songs', 'views/games'];

  for (const dir of dirs) {
    const files = fs.readdirSync(dir).filter(f => f.endsWith('.html'));
    views.push(...files.map(f => `${dir}/${f}`));
  }

  return views;
}
```

**Service worker cache:**
```javascript
const VIEW_CACHE = 'views-v1';
const VIEW_FILES = [
  'views/home.html',
  'views/tune.html',
  // ... (generated by build script)
];

self.addEventListener('fetch', event => {
  if (event.request.url.includes('/views/')) {
    event.respondWith(
      caches.match(event.request)
        .then(cached => cached || fetch(event.request))
    );
  }
});
```

### Error Handling

**Network failures:**
```javascript
async function navigate(viewId) {
  try {
    const html = await viewLoader.load(getViewPath(viewId));
    document.getElementById('main-container').innerHTML = html;
  } catch (err) {
    showError(`Failed to load view: ${err.message}`);
    console.error('View load error:', err);
  }
}
```

**Offline behavior:**
- Service worker serves cached views
- First visit requires network (acceptable for PWA)
- Install prompt guides offline setup

**Error UI:**
- User-friendly message
- Retry button
- Console logging for debugging

### View Extraction Process

**Build-time script:**
```javascript
// scripts/extract-views.js
function extractViews() {
  const html = fs.readFileSync('index.html', 'utf-8');
  const dom = parseHTML(html);

  const views = dom.querySelectorAll('.view');
  views.forEach(view => {
    const id = view.id;
    const content = view.innerHTML;
    const path = getViewPath(id);

    fs.writeFileSync(path, content);
  });

  // Remove views from index.html, keep shell
  removeViews(dom);
  fs.writeFileSync('index.html', dom.toString());
}
```

**Run during:** prebuild phase (after games/songs generation)

### Shell HTML

**What stays in index.html:**
- `<head>` with meta, styles, manifest
- Navigation elements
- Main container (empty `<main id="main-container">`)
- Global scripts
- Service worker registration

**Estimated size:** ~15 KB (shell structure + critical CSS)

## Data Flow

```
User clicks nav link
  ↓
Router intercepts
  ↓
Determine view path
  ↓
ViewLoader.load(path)
  ↓
Check cache → Return if found
  ↓
Fetch HTML file
  ↓
Cache response
  ↓
Return HTML
  ↓
Router injects into container
  ↓
Initialize view-specific JS
  ↓
View rendered
```

## Testing Strategy

### Unit Tests

**ViewLoader tests:**
- Caching behavior (hit/miss)
- Duplicate fetch prevention
- Error handling and cleanup
- Cache clearing

**Router tests:**
- Path mapping correctness
- View initialization
- Error recovery

### Integration Tests

**Service worker:**
- Precache registration
- Offline view loading
- Cache updates on new version

### E2E Tests

**Navigation:**
- Navigate to each view type (core, song, game)
- Verify content loads correctly
- Check navigation timing (<100ms)

**Offline:**
- Load app online
- Go offline
- Navigate between cached views
- Attempt navigation to uncached view (error handling)

**Performance:**
- Measure initial HTML parse time
- Measure first view load time
- Verify cache hits on repeat navigation

## Migration Path

1. Create extraction script
2. Run extraction (generates view files)
3. Implement ViewLoader module
4. Update router to use ViewLoader
5. Update service worker with view files
6. Update build pipeline
7. Test all navigation paths
8. Verify offline functionality
9. Measure performance gains

## Rollback Plan

- Keep original index.html in `_archived/`
- ViewLoader fails → fallback to inline views
- Service worker issues → unregister and reload
- Build issues → use pre-extraction index.html

## Performance Targets

- Initial HTML: <20 KB (vs 172 KB)
- First view load: <100ms (network dependent)
- Cached view load: <10ms (memory cache)
- Parse time: <50ms (vs ~200ms)

## Tech Stack

- Fetch API (native, no dependencies)
- Service Worker API (existing)
- ES modules (existing)
- Build scripts (Node.js, fs, cheerio for HTML parsing)

## Dependencies

None - uses existing dependencies and native browser APIs

## Open Questions

None - design is complete and ready for implementation
